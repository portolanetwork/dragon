turnstile {
  grpc {
    host = "0.0.0.0"
    port = 8080
  }

  grpc-web {
    enabled = true
    host = "0.0.0.0"
    port = 8081
  }

  # Authentication Configuration
  auth {
    # Auth0 settings
    server {
      enabled = true                 # Enable/disable server authentication
      domain = ${?AUTH0_DOMAIN}      # Override via environment variable
      audience = ${?AUTH0_AUDIENCE}  # Override via environment variable
    }
    client {
      callback-url = "http://localhost:8082/callback"
      audience = ${?AUTH0_CLIENT_AUDIENCE}
    }
  }

  cluster {
    num-shards = 24
  }

  mcp {
    streaming-http {
      enabled = true
      server-name = "Dragon MCP Streaming Server"
      server-version = "1.0.0"
      mcp-endpoint = "/mcp"
      host = "0.0.0.0"
      port = 8082

        # HTTPS/TLS Configuration (optional)
        # Uncomment and configure to enable HTTPS
        #ssl {
        #  enabled = true
        #  keystore-path = "src/main/resources/certs/keystore.p12"
        #  keystore-password = "changeit"
        #  keystore-type = "PKCS12"  # Options: PKCS12, JKS
        #}
    }
  }

  # Database Configuration - Slick with PostgreSQL + slick-pg (Neon DB)
  # Note: Code uses TurnstilePostgresProfile which extends slick-pg for JSONB support
  database {
    profile = "slick.jdbc.PostgresProfile$"

    db {
      driver = "org.postgresql.Driver"
      url = ${?DATABASE_URL}  # Override via environment variable
      user = "neondb_owner"
      user = ${?DATABASE_USER}
      password = ${?DATABASE_PASSWORD}

      # Connection pool settings (HikariCP)
      numThreads = 10
      maxConnections = 10
      minConnections = 1
      connectionTimeout = 5000
      keepAliveConnection = true

      # SSL/TLS properties for Neon DB
      properties {
        ssl = true
        sslmode = "require"
      }
    }
  }
}

pekko {
  loglevel = DEBUG

  http.server.preview.enable-http2 = on

  http {
    server {
      idle-timeout = 600s
    }
  }

  actor {
    provider = cluster

    # Disable Java serialization for security and performance
    # Only enable if absolutely necessary for legacy compatibility
    allow-java-serialization = off
    warn-about-java-serializer-usage = on

    # Define serializers explicitly
    serializers {
      jackson-json = "org.apache.pekko.serialization.jackson.JacksonJsonSerializer"
      jackson-cbor = "org.apache.pekko.serialization.jackson.JacksonCborSerializer"
      proto = "org.apache.pekko.remote.serialization.ProtobufSerializer"
    }

    # Bind message types to serializers
    serialization-bindings {
      # Use protobuf serializer for protobuf-generated messages
      "com.google.protobuf.Message" = proto
      "scalapb.GeneratedMessage" = proto

      # Use Jackson CBOR for custom serializable messages (more efficient than JSON)
      "app.dragon.turnstile.serializer.TurnstileSerializable" = jackson-cbor
    }


  }

  remote.artery {
    canonical {
      hostname = "127.0.0.1"
      port = 25520
    }
  }

  cluster {
    seed-nodes = [
      "pekko://turnstile@127.0.0.1:25520"
    ]

    sharding {
      number-of-shards = 100

      passivation {
        strategy = default-strategy
        default-strategy {
          active-entity-limit = 1000000
        }
      }
    }

    downing-provider-class = "org.apache.pekko.cluster.sbr.SplitBrainResolverProvider"
  }

  management {
    http {
      hostname = "127.0.0.1"
      port = 8558
    }

    cluster.bootstrap {
      contact-point-discovery {
        service-name = "turnstile"
        discovery-method = config
      }
      contact-point {
        required-contact-point-nr = 1
      }
    }
  }

  discovery {
    method = config
    config.services {
      turnstile {
        endpoints = [
          {
            host = "127.0.0.1"
            port = 8558
          }
        ]
      }
    }
  }
}

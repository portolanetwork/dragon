// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "dragon/turnstile/v1/turnstile_service.proto" (package "dragon.turnstile.v1", syntax proto3)
// tslint:disable
import { Empty } from "../../../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
/**
 * MCP Servers
 *
 * @generated from protobuf message dragon.turnstile.v1.AddMcpServerRequest
 */
export interface AddMcpServerRequest {
    /**
     * @generated from protobuf field: string name = 10;
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 20;
     */
    url: string;
    /**
     * @generated from protobuf field: dragon.turnstile.v1.AuthType auth_type = 30;
     */
    authType: AuthType; // Authentication type
    /**
     * @generated from protobuf field: string static_token = 40;
     */
    staticToken: string; // Static authentication token (optional, used with AUTH_TYPE_STATIC_HEADER)
}
/**
 * @generated from protobuf message dragon.turnstile.v1.ListMcpServersRequest
 */
export interface ListMcpServersRequest {
    /**
     * @generated from protobuf field: string user_id = 10;
     */
    userId: string; // string cursor = 20;
    // string page_size = 30;
}
/**
 * @generated from protobuf message dragon.turnstile.v1.RemoveMcpServerRequest
 */
export interface RemoveMcpServerRequest {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string;
}
/**
 * @generated from protobuf message dragon.turnstile.v1.McpServerList
 */
export interface McpServerList {
    /**
     * @generated from protobuf field: repeated dragon.turnstile.v1.McpServer mcp_server = 10;
     */
    mcpServer: McpServer[]; // string next_cursor = 20;
}
/**
 * OAuth configuration details (non-sensitive fields only)
 *
 * @generated from protobuf message dragon.turnstile.v1.OAuthConfig
 */
export interface OAuthConfig {
    /**
     * @generated from protobuf field: string client_id = 10;
     */
    clientId: string; // OAuth client ID (safe to expose)
    /**
     * @generated from protobuf field: string token_endpoint = 20;
     */
    tokenEndpoint: string; // OAuth token endpoint URL
    /**
     * @generated from protobuf field: bool has_client_secret = 30;
     */
    hasClientSecret: boolean; // Indicates if client secret is configured
    /**
     * @generated from protobuf field: bool has_refresh_token = 40;
     */
    hasRefreshToken: boolean; // Indicates if refresh token is stored
}
/**
 * @generated from protobuf message dragon.turnstile.v1.McpServer
 */
export interface McpServer {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string name = 20;
     */
    name: string;
    /**
     * @generated from protobuf field: string url = 30;
     */
    url: string;
    /**
     * @generated from protobuf field: dragon.turnstile.v1.AuthType auth_type = 40;
     */
    authType: AuthType; // Authentication type
    /**
     * @generated from protobuf field: dragon.turnstile.v1.TransportType transport_type = 50;
     */
    transportType: TransportType; // Transport type
    /**
     * @generated from protobuf field: bool has_static_token = 60;
     */
    hasStaticToken: boolean; // Indicates if a static token is configured (token value not returned for security)
    /**
     * @generated from protobuf field: dragon.turnstile.v1.OAuthConfig oauth_config = 70;
     */
    oauthConfig?: OAuthConfig; // OAuth configuration (only present for AUTH_TYPE_DISCOVER)
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 80;
     */
    createdAt?: Timestamp; // Creation timestamp
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 90;
     */
    updatedAt?: Timestamp; // Last update timestamp
}
/**
 * @generated from protobuf message dragon.turnstile.v1.GetLoginStatusForMcpServerRequest
 */
export interface GetLoginStatusForMcpServerRequest {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string; // UUID of the MCP server to check login status for
}
/**
 * @generated from protobuf message dragon.turnstile.v1.McpServerLoginStatus
 */
export interface McpServerLoginStatus {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string; // UUID of the MCP server
    /**
     * @generated from protobuf field: dragon.turnstile.v1.LoginStatus status = 20;
     */
    status: LoginStatus; // Current login status
    /**
     * @generated from protobuf field: dragon.turnstile.v1.AuthType auth_type = 30;
     */
    authType: AuthType; // Authentication type of the server
}
/**
 * @generated from protobuf message dragon.turnstile.v1.LoginMcpServerRequest
 */
export interface LoginMcpServerRequest {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string;
}
/**
 * @generated from protobuf message dragon.turnstile.v1.McpServerLoginUrl
 */
export interface McpServerLoginUrl {
    /**
     * @generated from protobuf field: string login_url = 10;
     */
    loginUrl: string;
}
/**
 * @generated from protobuf message dragon.turnstile.v1.LogoutMcpServerRequest
 */
export interface LogoutMcpServerRequest {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string;
}
/**
 * @generated from protobuf message dragon.turnstile.v1.LoadToolsForMcpServerRequest
 */
export interface LoadToolsForMcpServerRequest {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string;
}
/**
 * @generated from protobuf message dragon.turnstile.v1.UnloadToolsForMcpServerRequest
 */
export interface UnloadToolsForMcpServerRequest {
    /**
     * @generated from protobuf field: string uuid = 10;
     */
    uuid: string;
}
/**
 * Authentication types for MCP servers
 *
 * @generated from protobuf enum dragon.turnstile.v1.AuthType
 */
export enum AuthType {
    /**
     * @generated from protobuf enum value: AUTH_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * No authentication required
     *
     * @generated from protobuf enum value: AUTH_TYPE_NONE = 1;
     */
    NONE = 1,
    /**
     * Use OAuth discovery
     *
     * @generated from protobuf enum value: AUTH_TYPE_DISCOVER = 2;
     */
    DISCOVER = 2,
    /**
     * Static authentication header
     *
     * @generated from protobuf enum value: AUTH_TYPE_STATIC_HEADER = 3;
     */
    STATIC_HEADER = 3
}
/**
 * Login status for OAuth-enabled MCP servers
 *
 * @generated from protobuf enum dragon.turnstile.v1.LoginStatus
 */
export enum LoginStatus {
    /**
     * @generated from protobuf enum value: LOGIN_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * User has not authenticated yet
     *
     * @generated from protobuf enum value: LOGIN_STATUS_NOT_AUTHENTICATED = 1;
     */
    NOT_AUTHENTICATED = 1,
    /**
     * User is authenticated with valid tokens
     *
     * @generated from protobuf enum value: LOGIN_STATUS_AUTHENTICATED = 2;
     */
    AUTHENTICATED = 2,
    /**
     * Authentication has expired
     *
     * @generated from protobuf enum value: LOGIN_STATUS_EXPIRED = 3;
     */
    EXPIRED = 3,
    /**
     * Server does not require OAuth (AUTH_TYPE_NONE or AUTH_TYPE_STATIC_HEADER)
     *
     * @generated from protobuf enum value: LOGIN_STATUS_NOT_APPLICABLE = 4;
     */
    NOT_APPLICABLE = 4
}
/**
 * @generated from protobuf enum dragon.turnstile.v1.TransportType
 */
export enum TransportType {
    /**
     * @generated from protobuf enum value: TRANSPORT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TRANSPORT_TYPE_STREAMING_HTTP = 1;
     */
    STREAMING_HTTP = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class AddMcpServerRequest$Type extends MessageType<AddMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.AddMcpServerRequest", [
            { no: 10, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "auth_type", kind: "enum", T: () => ["dragon.turnstile.v1.AuthType", AuthType, "AUTH_TYPE_"] },
            { no: 40, name: "static_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddMcpServerRequest>): AddMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.url = "";
        message.authType = 0;
        message.staticToken = "";
        if (value !== undefined)
            reflectionMergePartial<AddMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddMcpServerRequest): AddMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 10:
                    message.name = reader.string();
                    break;
                case /* string url */ 20:
                    message.url = reader.string();
                    break;
                case /* dragon.turnstile.v1.AuthType auth_type */ 30:
                    message.authType = reader.int32();
                    break;
                case /* string static_token */ 40:
                    message.staticToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 10; */
        if (message.name !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.name);
        /* string url = 20; */
        if (message.url !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.url);
        /* dragon.turnstile.v1.AuthType auth_type = 30; */
        if (message.authType !== 0)
            writer.tag(30, WireType.Varint).int32(message.authType);
        /* string static_token = 40; */
        if (message.staticToken !== "")
            writer.tag(40, WireType.LengthDelimited).string(message.staticToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.AddMcpServerRequest
 */
export const AddMcpServerRequest = new AddMcpServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMcpServersRequest$Type extends MessageType<ListMcpServersRequest> {
    constructor() {
        super("dragon.turnstile.v1.ListMcpServersRequest", [
            { no: 10, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListMcpServersRequest>): ListMcpServersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<ListMcpServersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMcpServersRequest): ListMcpServersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 10:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMcpServersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 10; */
        if (message.userId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.ListMcpServersRequest
 */
export const ListMcpServersRequest = new ListMcpServersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveMcpServerRequest$Type extends MessageType<RemoveMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.RemoveMcpServerRequest", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveMcpServerRequest>): RemoveMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveMcpServerRequest): RemoveMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.RemoveMcpServerRequest
 */
export const RemoveMcpServerRequest = new RemoveMcpServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McpServerList$Type extends MessageType<McpServerList> {
    constructor() {
        super("dragon.turnstile.v1.McpServerList", [
            { no: 10, name: "mcp_server", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => McpServer }
        ]);
    }
    create(value?: PartialMessage<McpServerList>): McpServerList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mcpServer = [];
        if (value !== undefined)
            reflectionMergePartial<McpServerList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McpServerList): McpServerList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated dragon.turnstile.v1.McpServer mcp_server */ 10:
                    message.mcpServer.push(McpServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McpServerList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated dragon.turnstile.v1.McpServer mcp_server = 10; */
        for (let i = 0; i < message.mcpServer.length; i++)
            McpServer.internalBinaryWrite(message.mcpServer[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.McpServerList
 */
export const McpServerList = new McpServerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OAuthConfig$Type extends MessageType<OAuthConfig> {
    constructor() {
        super("dragon.turnstile.v1.OAuthConfig", [
            { no: 10, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "token_endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "has_client_secret", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "has_refresh_token", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OAuthConfig>): OAuthConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientId = "";
        message.tokenEndpoint = "";
        message.hasClientSecret = false;
        message.hasRefreshToken = false;
        if (value !== undefined)
            reflectionMergePartial<OAuthConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OAuthConfig): OAuthConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 10:
                    message.clientId = reader.string();
                    break;
                case /* string token_endpoint */ 20:
                    message.tokenEndpoint = reader.string();
                    break;
                case /* bool has_client_secret */ 30:
                    message.hasClientSecret = reader.bool();
                    break;
                case /* bool has_refresh_token */ 40:
                    message.hasRefreshToken = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OAuthConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 10; */
        if (message.clientId !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.clientId);
        /* string token_endpoint = 20; */
        if (message.tokenEndpoint !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.tokenEndpoint);
        /* bool has_client_secret = 30; */
        if (message.hasClientSecret !== false)
            writer.tag(30, WireType.Varint).bool(message.hasClientSecret);
        /* bool has_refresh_token = 40; */
        if (message.hasRefreshToken !== false)
            writer.tag(40, WireType.Varint).bool(message.hasRefreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.OAuthConfig
 */
export const OAuthConfig = new OAuthConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McpServer$Type extends MessageType<McpServer> {
    constructor() {
        super("dragon.turnstile.v1.McpServer", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "auth_type", kind: "enum", T: () => ["dragon.turnstile.v1.AuthType", AuthType, "AUTH_TYPE_"] },
            { no: 50, name: "transport_type", kind: "enum", T: () => ["dragon.turnstile.v1.TransportType", TransportType, "TRANSPORT_TYPE_"] },
            { no: 60, name: "has_static_token", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 70, name: "oauth_config", kind: "message", T: () => OAuthConfig },
            { no: 80, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 90, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<McpServer>): McpServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        message.url = "";
        message.authType = 0;
        message.transportType = 0;
        message.hasStaticToken = false;
        if (value !== undefined)
            reflectionMergePartial<McpServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McpServer): McpServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 20:
                    message.name = reader.string();
                    break;
                case /* string url */ 30:
                    message.url = reader.string();
                    break;
                case /* dragon.turnstile.v1.AuthType auth_type */ 40:
                    message.authType = reader.int32();
                    break;
                case /* dragon.turnstile.v1.TransportType transport_type */ 50:
                    message.transportType = reader.int32();
                    break;
                case /* bool has_static_token */ 60:
                    message.hasStaticToken = reader.bool();
                    break;
                case /* dragon.turnstile.v1.OAuthConfig oauth_config */ 70:
                    message.oauthConfig = OAuthConfig.internalBinaryRead(reader, reader.uint32(), options, message.oauthConfig);
                    break;
                case /* google.protobuf.Timestamp created_at */ 80:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 90:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McpServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        /* string name = 20; */
        if (message.name !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.name);
        /* string url = 30; */
        if (message.url !== "")
            writer.tag(30, WireType.LengthDelimited).string(message.url);
        /* dragon.turnstile.v1.AuthType auth_type = 40; */
        if (message.authType !== 0)
            writer.tag(40, WireType.Varint).int32(message.authType);
        /* dragon.turnstile.v1.TransportType transport_type = 50; */
        if (message.transportType !== 0)
            writer.tag(50, WireType.Varint).int32(message.transportType);
        /* bool has_static_token = 60; */
        if (message.hasStaticToken !== false)
            writer.tag(60, WireType.Varint).bool(message.hasStaticToken);
        /* dragon.turnstile.v1.OAuthConfig oauth_config = 70; */
        if (message.oauthConfig)
            OAuthConfig.internalBinaryWrite(message.oauthConfig, writer.tag(70, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 80; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(80, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 90; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(90, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.McpServer
 */
export const McpServer = new McpServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLoginStatusForMcpServerRequest$Type extends MessageType<GetLoginStatusForMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.GetLoginStatusForMcpServerRequest", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetLoginStatusForMcpServerRequest>): GetLoginStatusForMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<GetLoginStatusForMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLoginStatusForMcpServerRequest): GetLoginStatusForMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLoginStatusForMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.GetLoginStatusForMcpServerRequest
 */
export const GetLoginStatusForMcpServerRequest = new GetLoginStatusForMcpServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McpServerLoginStatus$Type extends MessageType<McpServerLoginStatus> {
    constructor() {
        super("dragon.turnstile.v1.McpServerLoginStatus", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "status", kind: "enum", T: () => ["dragon.turnstile.v1.LoginStatus", LoginStatus, "LOGIN_STATUS_"] },
            { no: 30, name: "auth_type", kind: "enum", T: () => ["dragon.turnstile.v1.AuthType", AuthType, "AUTH_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<McpServerLoginStatus>): McpServerLoginStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.status = 0;
        message.authType = 0;
        if (value !== undefined)
            reflectionMergePartial<McpServerLoginStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McpServerLoginStatus): McpServerLoginStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                case /* dragon.turnstile.v1.LoginStatus status */ 20:
                    message.status = reader.int32();
                    break;
                case /* dragon.turnstile.v1.AuthType auth_type */ 30:
                    message.authType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McpServerLoginStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        /* dragon.turnstile.v1.LoginStatus status = 20; */
        if (message.status !== 0)
            writer.tag(20, WireType.Varint).int32(message.status);
        /* dragon.turnstile.v1.AuthType auth_type = 30; */
        if (message.authType !== 0)
            writer.tag(30, WireType.Varint).int32(message.authType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.McpServerLoginStatus
 */
export const McpServerLoginStatus = new McpServerLoginStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginMcpServerRequest$Type extends MessageType<LoginMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.LoginMcpServerRequest", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginMcpServerRequest>): LoginMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<LoginMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginMcpServerRequest): LoginMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.LoginMcpServerRequest
 */
export const LoginMcpServerRequest = new LoginMcpServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class McpServerLoginUrl$Type extends MessageType<McpServerLoginUrl> {
    constructor() {
        super("dragon.turnstile.v1.McpServerLoginUrl", [
            { no: 10, name: "login_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<McpServerLoginUrl>): McpServerLoginUrl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.loginUrl = "";
        if (value !== undefined)
            reflectionMergePartial<McpServerLoginUrl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: McpServerLoginUrl): McpServerLoginUrl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string login_url */ 10:
                    message.loginUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: McpServerLoginUrl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string login_url = 10; */
        if (message.loginUrl !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.loginUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.McpServerLoginUrl
 */
export const McpServerLoginUrl = new McpServerLoginUrl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogoutMcpServerRequest$Type extends MessageType<LogoutMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.LogoutMcpServerRequest", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogoutMcpServerRequest>): LogoutMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<LogoutMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutMcpServerRequest): LogoutMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.LogoutMcpServerRequest
 */
export const LogoutMcpServerRequest = new LogoutMcpServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadToolsForMcpServerRequest$Type extends MessageType<LoadToolsForMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.LoadToolsForMcpServerRequest", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoadToolsForMcpServerRequest>): LoadToolsForMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<LoadToolsForMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadToolsForMcpServerRequest): LoadToolsForMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadToolsForMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.LoadToolsForMcpServerRequest
 */
export const LoadToolsForMcpServerRequest = new LoadToolsForMcpServerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnloadToolsForMcpServerRequest$Type extends MessageType<UnloadToolsForMcpServerRequest> {
    constructor() {
        super("dragon.turnstile.v1.UnloadToolsForMcpServerRequest", [
            { no: 10, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnloadToolsForMcpServerRequest>): UnloadToolsForMcpServerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<UnloadToolsForMcpServerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnloadToolsForMcpServerRequest): UnloadToolsForMcpServerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 10:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnloadToolsForMcpServerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 10; */
        if (message.uuid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message dragon.turnstile.v1.UnloadToolsForMcpServerRequest
 */
export const UnloadToolsForMcpServerRequest = new UnloadToolsForMcpServerRequest$Type();
/**
 * @generated ServiceType for protobuf service dragon.turnstile.v1.TurnstileService
 */
export const TurnstileService = new ServiceType("dragon.turnstile.v1.TurnstileService", [
    { name: "ListMcpServers", options: {}, I: ListMcpServersRequest, O: McpServerList },
    { name: "AddMcpServer", options: {}, I: AddMcpServerRequest, O: McpServer },
    { name: "RemoveMcpServer", options: {}, I: RemoveMcpServerRequest, O: Empty },
    { name: "GetLoginStatusForMcpServer", options: {}, I: GetLoginStatusForMcpServerRequest, O: McpServerLoginStatus },
    { name: "LoginMcpServer", options: {}, I: LoginMcpServerRequest, O: McpServerLoginUrl },
    { name: "LogoutMcpServer", options: {}, I: LogoutMcpServerRequest, O: Empty },
    { name: "LoadToolsForMcpServer", options: {}, I: LoadToolsForMcpServerRequest, O: Empty },
    { name: "UnloadToolsForMcpServer", options: {}, I: UnloadToolsForMcpServerRequest, O: Empty }
]);

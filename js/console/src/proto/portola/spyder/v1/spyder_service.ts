// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "portola/spyder/v1/spyder_service.proto" (package "portola.spyder.api.v1", syntax proto3)
// tslint:disable
import { DirListing } from "../../common/v1/objects";
import { TunnelList } from "../../common/v1/objects";
import { Tunnel } from "../../common/v1/objects";
import { ChatLocator } from "../../common/v1/objects";
import { GrpcResponse } from "./common";
import { Empty } from "../../../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ConnectorExportLocator } from "../../common/v1/objects";
import { Connector } from "../../common/v1/objects";
import { SemanticVersion } from "../../common/v1/objects";
import { TunnelLocator } from "../../common/v1/objects";
import { EndpointFilepath } from "../../common/v1/objects";
import { EndpointLocator } from "../../common/v1/objects";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { UserLocator } from "../../common/v1/objects";
/**
 * /
 *
 * @generated from protobuf message portola.spyder.api.v1.CreateChatRequet
 */
export interface CreateChatRequet {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.GetAllChatRequest
 */
export interface GetAllChatRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.UserLocator user_locator = 1;
     */
    userLocator?: UserLocator;
    /**
     * @generated from protobuf field: string cursor = 2;
     */
    cursor: string; // Will return from fist element after cursor
    /**
     * @generated from protobuf field: int32 limit = 3;
     */
    limit: number;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.ChatList
 */
export interface ChatList {
    /**
     * @generated from protobuf field: repeated portola.spyder.api.v1.Chat chat_list = 1;
     */
    chatList: Chat[];
    /**
     * @generated from protobuf field: string cursor = 2;
     */
    cursor: string; // Cusor pointing to final element in return
    /**
     * @generated from protobuf field: bool has_more = 3;
     */
    hasMore: boolean;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.Chat
 */
export interface Chat {
    /**
     * @generated from protobuf field: string chat_id = 1;
     */
    chatId: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 3;
     */
    updatedAt?: Timestamp;
}
/**
 * /
 *
 * @generated from protobuf message portola.spyder.api.v1.CreateStripeCheckoutSessionRequest
 */
export interface CreateStripeCheckoutSessionRequest {
    /**
     * @generated from protobuf field: string lookup_key = 1;
     */
    lookupKey: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CreateStripeCheckoutSessionResponse
 */
export interface CreateStripeCheckoutSessionResponse {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CreateStripePortalSessionRequest
 */
export interface CreateStripePortalSessionRequest {
    /**
     * @generated from protobuf field: string session_id = 1;
     */
    sessionId: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CreateStripePortalSessionResponse
 */
export interface CreateStripePortalSessionResponse {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
// message StripeWebhookRequest {
//    string payload = 1;
//    string signature = 2;
// }
// message StripeWebhookResponse {
//    string status = 1;
// }

// /

/**
 * @generated from protobuf message portola.spyder.api.v1.UpsertPublicKeyRequest
 */
export interface UpsertPublicKeyRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf field: string public_key = 2;
     */
    publicKey: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.GetPublicKeyRequest
 */
export interface GetPublicKeyRequest {
    /**
     * @generated from protobuf field: string tunnel_id = 1;
     */
    tunnelId: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.PublicKey
 */
export interface PublicKey {
    /**
     * @generated from protobuf field: repeated string public_key = 1;
     */
    publicKey: string[];
}
/**
 * @generated from protobuf message portola.spyder.api.v1.Token
 */
export interface Token {
    /**
     * @generated from protobuf field: string access_token = 1;
     */
    accessToken: string;
    /**
     * string refresh_token = 2;
     *
     * @generated from protobuf field: int32 expires_in = 3;
     */
    expiresIn: number;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.ClientList
 */
export interface ClientList {
    /**
     * @generated from protobuf field: repeated portola.spyder.api.v1.Client client_list = 1;
     */
    clientList: Client[];
}
/**
 * @generated from protobuf message portola.spyder.api.v1.Client
 */
export interface Client {
    /**
     * @generated from protobuf field: string client_tenant_id = 1;
     */
    clientTenantId: string;
    /**
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * @generated from protobuf field: string client_secret = 3;
     */
    clientSecret: string;
    /**
     * @generated from protobuf field: string endpoint_id = 4;
     */
    endpointId: string;
}
/**
 * /
 *
 * @generated from protobuf message portola.spyder.api.v1.AuthDataRequest
 */
export interface AuthDataRequest {
    /**
     * @generated from protobuf field: string access_token = 1;
     */
    accessToken: string;
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
    /**
     * @generated from protobuf field: string code_challenge = 3;
     */
    codeChallenge: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.RedemptionCode
 */
export interface RedemptionCode {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.RedeemAuthDataRequest
 */
export interface RedeemAuthDataRequest {
    /**
     * @generated from protobuf field: string code = 1;
     */
    code: string;
    /**
     * @generated from protobuf field: string code_verifier = 2;
     */
    codeVerifier: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.AuthData
 */
export interface AuthData {
    /**
     * @generated from protobuf field: string access_token = 1;
     */
    accessToken: string;
    /**
     * @generated from protobuf field: string refresh_token = 2;
     */
    refreshToken: string;
}
// /

/**
 * @generated from protobuf message portola.spyder.api.v1.ReadDirRequest
 */
export interface ReadDirRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointFilepath endpoint_filepath = 1;
     */
    endpointFilepath?: EndpointFilepath;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CreatePathRequest
 */
export interface CreatePathRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointFilepath endpoint_filepath = 1;
     */
    endpointFilepath?: EndpointFilepath;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.TrashPathRequest
 */
export interface TrashPathRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointFilepath endpoint_filepath = 1;
     */
    endpointFilepath?: EndpointFilepath;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.RenamePathRequest
 */
export interface RenamePathRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointFilepath endpoint_filepath = 1;
     */
    endpointFilepath?: EndpointFilepath;
    /**
     * @generated from protobuf field: string new_path = 2;
     */
    newPath: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CopyPathRequest
 */
export interface CopyPathRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.TunnelLocator tunnel_locator = 2;
     */
    tunnelLocator?: TunnelLocator;
    /**
     * @generated from protobuf field: string server_path = 4;
     */
    serverPath: string;
    /**
     * @generated from protobuf field: string client_path = 5;
     */
    clientPath: string;
    /**
     * @generated from protobuf field: bool is_upload = 6;
     */
    isUpload: boolean;
}
// /

/**
 * @generated from protobuf message portola.spyder.api.v1.AppConfig
 */
export interface AppConfig {
    /**
     * @generated from protobuf field: string base_url = 1;
     */
    baseUrl: string;
    /**
     * @generated from protobuf field: bool tls_enabled = 2;
     */
    tlsEnabled: boolean;
    /**
     * @generated from protobuf field: bool tls_skip_verify = 3;
     */
    tlsSkipVerify: boolean;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.EndpointConfig
 */
export interface EndpointConfig {
    /**
     * @generated from protobuf field: portola.spyder.api.v1.AppConfig endpoint_service_config = 1;
     */
    endpointServiceConfig?: AppConfig;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.UpgradeEndpointRequest
 */
export interface UpgradeEndpointRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf field: portola.common.api.v1.SemanticVersion desired_version = 2;
     */
    desiredVersion?: SemanticVersion;
}
// message AutoUpgradeEndpointRequest {
//    portola.common.api.v1.EndpointLocator endpoint_locator = 1;
//   bool enableAuthUpgrade = 2;
// }

/**
 * @generated from protobuf message portola.spyder.api.v1.CaffeinateEndpointRequest
 */
export interface CaffeinateEndpointRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf field: bool is_caffeinated = 2;
     */
    isCaffeinated: boolean;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CertificateSigningRequest
 */
export interface CertificateSigningRequest {
    /**
     * @generated from protobuf field: string csr = 1;
     */
    csr: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.Certificate
 */
export interface Certificate {
    /**
     * @generated from protobuf field: string cert = 2;
     */
    cert: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.EndpointStatus
 */
export interface EndpointStatus {
    /**
     * @generated from protobuf field: portola.spyder.api.v1.StatusEnum status_enum = 1;
     */
    statusEnum: StatusEnum;
    /**
     * @generated from protobuf field: int64 last_online_sec = 2;
     */
    lastOnlineSec: bigint;
    /**
     * @generated from protobuf field: bool is_caffeinated = 3;
     */
    isCaffeinated: boolean;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.PublishHubRequest
 */
export interface PublishHubRequest {
    /**
     * @generated from protobuf field: string hub = 1;
     */
    hub: string;
    /**
     * @generated from protobuf field: repeated portola.common.api.v1.EndpointLocator endpoint_locator_list = 2;
     */
    endpointLocatorList: EndpointLocator[];
}
/**
 * @generated from protobuf message portola.spyder.api.v1.UnpublishHubRequest
 */
export interface UnpublishHubRequest {
    /**
     * @generated from protobuf field: string hub = 1;
     */
    hub: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.PublishEndpointRequest
 */
export interface PublishEndpointRequest {
    /**
     * @generated from protobuf field: string hub = 1;
     */
    hub: string;
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 2;
     */
    endpointLocator?: EndpointLocator;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.UnpublishEndpointRequest
 */
export interface UnpublishEndpointRequest {
    /**
     * @generated from protobuf field: string hub = 1;
     */
    hub: string;
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 2;
     */
    endpointLocator?: EndpointLocator;
}
// Tunnel

/**
 * @generated from protobuf message portola.spyder.api.v1.CreateTunnelRequest
 */
export interface CreateTunnelRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector left_connector = 1;
     */
    leftConnector?: Connector;
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector right_connector = 2;
     */
    rightConnector?: Connector;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CreateTunnelFromExportRequest
 */
export interface CreateTunnelFromExportRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector right_connector = 1;
     */
    rightConnector?: Connector;
    /**
     * @generated from protobuf field: portola.common.api.v1.ConnectorExportLocator connector_export_locator = 2;
     */
    connectorExportLocator?: ConnectorExportLocator;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.GetAllConnectorExportsFromMeRequest
 */
export interface GetAllConnectorExportsFromMeRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string endpoint_id = 2;
     */
    endpointId: string;
    /**
     * @generated from protobuf field: string connector_id = 3;
     */
    connectorId: string;
}
// message Tunnel {
//  portola.common.api.v1.TunnelLocator tunnel_locator = 1;
//  portola.common.api.v1.Connector left_connector = 2;
//  portola.common.api.v1.Connector right_connector = 3;
// }

// message TunnelList {
//  repeated Tunnel tunnel_list = 1;
// }

/**
 * @generated from protobuf message portola.spyder.api.v1.FindTunnelsRequest
 */
export interface FindTunnelsRequest {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string endpoint_id = 2;
     */
    endpointId: string;
}
/**
 * ConnectorExport
 *
 * @generated from protobuf message portola.spyder.api.v1.CreateConnectorExportRequest
 */
export interface CreateConnectorExportRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector left_connector = 1;
     */
    leftConnector?: Connector;
    /**
     * @generated from protobuf field: portola.spyder.api.v1.ConnectorAccessControl connector_access_control = 2;
     */
    connectorAccessControl?: ConnectorAccessControl;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.ConnectorAccessControl
 */
export interface ConnectorAccessControl {
    /**
     * @generated from protobuf field: string userId = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string email = 2;
     */
    email: string; // email (verified)
}
/**
 * @generated from protobuf message portola.spyder.api.v1.ConnectorExport
 */
export interface ConnectorExport {
    /**
     * @generated from protobuf field: portola.common.api.v1.ConnectorExportLocator connector_export_locator = 1;
     */
    connectorExportLocator?: ConnectorExportLocator;
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector connector = 2;
     */
    connector?: Connector;
    /**
     * @generated from protobuf field: portola.spyder.api.v1.ConnectorAccessControl connector_access_control = 3;
     */
    connectorAccessControl?: ConnectorAccessControl;
    /**
     * @generated from protobuf field: portola.spyder.api.v1.User from_user = 4;
     */
    fromUser?: User;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.ConnectorExportList
 */
export interface ConnectorExportList {
    /**
     * @generated from protobuf field: repeated portola.spyder.api.v1.ConnectorExport connector_export_list = 1;
     */
    connectorExportList: ConnectorExport[];
}
/**
 * User
 *
 * @generated from protobuf message portola.spyder.api.v1.CreateUserRequest
 */
export interface CreateUserRequest {
}
/**
 * @generated from protobuf message portola.spyder.api.v1.CreateClientRequest
 */
export interface CreateClientRequest {
    /**
     * @generated from protobuf field: string endpoint_id = 1;
     */
    endpointId: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.User
 */
export interface User {
    /**
     * @generated from protobuf field: portola.common.api.v1.UserLocator user_locator = 1;
     */
    userLocator?: UserLocator;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: bool email_verified = 4;
     */
    emailVerified: boolean;
    /**
     * @generated from protobuf field: string picture = 5;
     */
    picture: string;
    /**
     * @generated from protobuf field: string firebase = 6;
     */
    firebase: string;
}
/**
 * Endpoint
 *
 * @generated from protobuf message portola.spyder.api.v1.UpsertEndpointRequest
 */
export interface UpsertEndpointRequest {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf field: string hostname = 2;
     */
    hostname: string; // Misc user info
    /**
     * @generated from protobuf field: string agent_version = 3;
     */
    agentVersion: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp agent_build_date = 4;
     */
    agentBuildDate?: Timestamp;
    /**
     * @generated from protobuf field: string homedir = 5;
     */
    homedir: string;
    /**
     * @generated from protobuf field: string username = 6;
     */
    username: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.Endpoint
 */
export interface Endpoint {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf field: string hostname = 2;
     */
    hostname: string;
    /**
     * @generated from protobuf field: string agent_version = 3;
     */
    agentVersion: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp agent_build_date = 4;
     */
    agentBuildDate?: Timestamp;
    /**
     * @generated from protobuf field: string homedir = 5;
     */
    homedir: string;
    /**
     * @generated from protobuf field: string username = 6;
     */
    username: string;
}
/**
 * @generated from protobuf message portola.spyder.api.v1.EndpointList
 */
export interface EndpointList {
    /**
     * @generated from protobuf field: repeated portola.spyder.api.v1.Endpoint endpoint_list = 1;
     */
    endpointList: Endpoint[];
}
/**
 * @generated from protobuf enum portola.spyder.api.v1.StatusEnum
 */
export enum StatusEnum {
    /**
     * @generated from protobuf enum value: UNKNOWN_STATE = 0;
     */
    UNKNOWN_STATE = 0,
    /**
     * @generated from protobuf enum value: ONLINE_STATE = 1;
     */
    ONLINE_STATE = 1,
    /**
     * @generated from protobuf enum value: OFFLINE_STATE = 2;
     */
    OFFLINE_STATE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class CreateChatRequet$Type extends MessageType<CreateChatRequet> {
    constructor() {
        super("portola.spyder.api.v1.CreateChatRequet", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateChatRequet>): CreateChatRequet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<CreateChatRequet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateChatRequet): CreateChatRequet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateChatRequet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateChatRequet
 */
export const CreateChatRequet = new CreateChatRequet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllChatRequest$Type extends MessageType<GetAllChatRequest> {
    constructor() {
        super("portola.spyder.api.v1.GetAllChatRequest", [
            { no: 1, name: "user_locator", kind: "message", T: () => UserLocator },
            { no: 2, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllChatRequest>): GetAllChatRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cursor = "";
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<GetAllChatRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllChatRequest): GetAllChatRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.UserLocator user_locator */ 1:
                    message.userLocator = UserLocator.internalBinaryRead(reader, reader.uint32(), options, message.userLocator);
                    break;
                case /* string cursor */ 2:
                    message.cursor = reader.string();
                    break;
                case /* int32 limit */ 3:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllChatRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.UserLocator user_locator = 1; */
        if (message.userLocator)
            UserLocator.internalBinaryWrite(message.userLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string cursor = 2; */
        if (message.cursor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cursor);
        /* int32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.GetAllChatRequest
 */
export const GetAllChatRequest = new GetAllChatRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatList$Type extends MessageType<ChatList> {
    constructor() {
        super("portola.spyder.api.v1.ChatList", [
            { no: 1, name: "chat_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Chat },
            { no: 2, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "has_more", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChatList>): ChatList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chatList = [];
        message.cursor = "";
        message.hasMore = false;
        if (value !== undefined)
            reflectionMergePartial<ChatList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatList): ChatList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated portola.spyder.api.v1.Chat chat_list */ 1:
                    message.chatList.push(Chat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string cursor */ 2:
                    message.cursor = reader.string();
                    break;
                case /* bool has_more */ 3:
                    message.hasMore = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated portola.spyder.api.v1.Chat chat_list = 1; */
        for (let i = 0; i < message.chatList.length; i++)
            Chat.internalBinaryWrite(message.chatList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string cursor = 2; */
        if (message.cursor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cursor);
        /* bool has_more = 3; */
        if (message.hasMore !== false)
            writer.tag(3, WireType.Varint).bool(message.hasMore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.ChatList
 */
export const ChatList = new ChatList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chat$Type extends MessageType<Chat> {
    constructor() {
        super("portola.spyder.api.v1.Chat", [
            { no: 1, name: "chat_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Chat>): Chat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chatId = "";
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<Chat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chat): Chat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string chat_id */ 1:
                    message.chatId = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* google.protobuf.Timestamp updated_at */ 3:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string chat_id = 1; */
        if (message.chatId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.chatId);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* google.protobuf.Timestamp updated_at = 3; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.Chat
 */
export const Chat = new Chat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStripeCheckoutSessionRequest$Type extends MessageType<CreateStripeCheckoutSessionRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateStripeCheckoutSessionRequest", [
            { no: 1, name: "lookup_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateStripeCheckoutSessionRequest>): CreateStripeCheckoutSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lookupKey = "";
        if (value !== undefined)
            reflectionMergePartial<CreateStripeCheckoutSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStripeCheckoutSessionRequest): CreateStripeCheckoutSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string lookup_key */ 1:
                    message.lookupKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStripeCheckoutSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string lookup_key = 1; */
        if (message.lookupKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.lookupKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateStripeCheckoutSessionRequest
 */
export const CreateStripeCheckoutSessionRequest = new CreateStripeCheckoutSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStripeCheckoutSessionResponse$Type extends MessageType<CreateStripeCheckoutSessionResponse> {
    constructor() {
        super("portola.spyder.api.v1.CreateStripeCheckoutSessionResponse", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateStripeCheckoutSessionResponse>): CreateStripeCheckoutSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<CreateStripeCheckoutSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStripeCheckoutSessionResponse): CreateStripeCheckoutSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStripeCheckoutSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateStripeCheckoutSessionResponse
 */
export const CreateStripeCheckoutSessionResponse = new CreateStripeCheckoutSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStripePortalSessionRequest$Type extends MessageType<CreateStripePortalSessionRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateStripePortalSessionRequest", [
            { no: 1, name: "session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateStripePortalSessionRequest>): CreateStripePortalSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateStripePortalSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStripePortalSessionRequest): CreateStripePortalSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string session_id */ 1:
                    message.sessionId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStripePortalSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string session_id = 1; */
        if (message.sessionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sessionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateStripePortalSessionRequest
 */
export const CreateStripePortalSessionRequest = new CreateStripePortalSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateStripePortalSessionResponse$Type extends MessageType<CreateStripePortalSessionResponse> {
    constructor() {
        super("portola.spyder.api.v1.CreateStripePortalSessionResponse", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateStripePortalSessionResponse>): CreateStripePortalSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<CreateStripePortalSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateStripePortalSessionResponse): CreateStripePortalSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateStripePortalSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateStripePortalSessionResponse
 */
export const CreateStripePortalSessionResponse = new CreateStripePortalSessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertPublicKeyRequest$Type extends MessageType<UpsertPublicKeyRequest> {
    constructor() {
        super("portola.spyder.api.v1.UpsertPublicKeyRequest", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "public_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpsertPublicKeyRequest>): UpsertPublicKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKey = "";
        if (value !== undefined)
            reflectionMergePartial<UpsertPublicKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertPublicKeyRequest): UpsertPublicKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* string public_key */ 2:
                    message.publicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertPublicKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string public_key = 2; */
        if (message.publicKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.UpsertPublicKeyRequest
 */
export const UpsertPublicKeyRequest = new UpsertPublicKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPublicKeyRequest$Type extends MessageType<GetPublicKeyRequest> {
    constructor() {
        super("portola.spyder.api.v1.GetPublicKeyRequest", [
            { no: 1, name: "tunnel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPublicKeyRequest>): GetPublicKeyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tunnelId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPublicKeyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPublicKeyRequest): GetPublicKeyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tunnel_id */ 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPublicKeyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tunnel_id = 1; */
        if (message.tunnelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tunnelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.GetPublicKeyRequest
 */
export const GetPublicKeyRequest = new GetPublicKeyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKey$Type extends MessageType<PublicKey> {
    constructor() {
        super("portola.spyder.api.v1.PublicKey", [
            { no: 1, name: "public_key", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublicKey>): PublicKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.publicKey = [];
        if (value !== undefined)
            reflectionMergePartial<PublicKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKey): PublicKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string public_key */ 1:
                    message.publicKey.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string public_key = 1; */
        for (let i = 0; i < message.publicKey.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.publicKey[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.PublicKey
 */
export const PublicKey = new PublicKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token$Type extends MessageType<Token> {
    constructor() {
        super("portola.spyder.api.v1.Token", [
            { no: 1, name: "access_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "expires_in", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Token>): Token {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.expiresIn = 0;
        if (value !== undefined)
            reflectionMergePartial<Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* int32 expires_in */ 3:
                    message.expiresIn = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_token = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* int32 expires_in = 3; */
        if (message.expiresIn !== 0)
            writer.tag(3, WireType.Varint).int32(message.expiresIn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.Token
 */
export const Token = new Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientList$Type extends MessageType<ClientList> {
    constructor() {
        super("portola.spyder.api.v1.ClientList", [
            { no: 1, name: "client_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Client }
        ]);
    }
    create(value?: PartialMessage<ClientList>): ClientList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientList = [];
        if (value !== undefined)
            reflectionMergePartial<ClientList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientList): ClientList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated portola.spyder.api.v1.Client client_list */ 1:
                    message.clientList.push(Client.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated portola.spyder.api.v1.Client client_list = 1; */
        for (let i = 0; i < message.clientList.length; i++)
            Client.internalBinaryWrite(message.clientList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.ClientList
 */
export const ClientList = new ClientList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Client$Type extends MessageType<Client> {
    constructor() {
        super("portola.spyder.api.v1.Client", [
            { no: 1, name: "client_tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "client_secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "endpoint_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Client>): Client {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientTenantId = "";
        message.clientId = "";
        message.clientSecret = "";
        message.endpointId = "";
        if (value !== undefined)
            reflectionMergePartial<Client>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Client): Client {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_tenant_id */ 1:
                    message.clientTenantId = reader.string();
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* string client_secret */ 3:
                    message.clientSecret = reader.string();
                    break;
                case /* string endpoint_id */ 4:
                    message.endpointId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Client, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_tenant_id = 1; */
        if (message.clientTenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientTenantId);
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* string client_secret = 3; */
        if (message.clientSecret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.clientSecret);
        /* string endpoint_id = 4; */
        if (message.endpointId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endpointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.Client
 */
export const Client = new Client$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthDataRequest$Type extends MessageType<AuthDataRequest> {
    constructor() {
        super("portola.spyder.api.v1.AuthDataRequest", [
            { no: 1, name: "access_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code_challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthDataRequest>): AuthDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.refreshToken = "";
        message.codeChallenge = "";
        if (value !== undefined)
            reflectionMergePartial<AuthDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthDataRequest): AuthDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                case /* string code_challenge */ 3:
                    message.codeChallenge = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_token = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        /* string code_challenge = 3; */
        if (message.codeChallenge !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.codeChallenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.AuthDataRequest
 */
export const AuthDataRequest = new AuthDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedemptionCode$Type extends MessageType<RedemptionCode> {
    constructor() {
        super("portola.spyder.api.v1.RedemptionCode", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RedemptionCode>): RedemptionCode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        if (value !== undefined)
            reflectionMergePartial<RedemptionCode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedemptionCode): RedemptionCode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedemptionCode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.RedemptionCode
 */
export const RedemptionCode = new RedemptionCode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedeemAuthDataRequest$Type extends MessageType<RedeemAuthDataRequest> {
    constructor() {
        super("portola.spyder.api.v1.RedeemAuthDataRequest", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code_verifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RedeemAuthDataRequest>): RedeemAuthDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.codeVerifier = "";
        if (value !== undefined)
            reflectionMergePartial<RedeemAuthDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedeemAuthDataRequest): RedeemAuthDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string code_verifier */ 2:
                    message.codeVerifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedeemAuthDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string code_verifier = 2; */
        if (message.codeVerifier !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.codeVerifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.RedeemAuthDataRequest
 */
export const RedeemAuthDataRequest = new RedeemAuthDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthData$Type extends MessageType<AuthData> {
    constructor() {
        super("portola.spyder.api.v1.AuthData", [
            { no: 1, name: "access_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refresh_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthData>): AuthData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessToken = "";
        message.refreshToken = "";
        if (value !== undefined)
            reflectionMergePartial<AuthData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthData): AuthData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_token */ 1:
                    message.accessToken = reader.string();
                    break;
                case /* string refresh_token */ 2:
                    message.refreshToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_token = 1; */
        if (message.accessToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessToken);
        /* string refresh_token = 2; */
        if (message.refreshToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.AuthData
 */
export const AuthData = new AuthData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadDirRequest$Type extends MessageType<ReadDirRequest> {
    constructor() {
        super("portola.spyder.api.v1.ReadDirRequest", [
            { no: 1, name: "endpoint_filepath", kind: "message", T: () => EndpointFilepath }
        ]);
    }
    create(value?: PartialMessage<ReadDirRequest>): ReadDirRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReadDirRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadDirRequest): ReadDirRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointFilepath endpoint_filepath */ 1:
                    message.endpointFilepath = EndpointFilepath.internalBinaryRead(reader, reader.uint32(), options, message.endpointFilepath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadDirRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointFilepath endpoint_filepath = 1; */
        if (message.endpointFilepath)
            EndpointFilepath.internalBinaryWrite(message.endpointFilepath, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.ReadDirRequest
 */
export const ReadDirRequest = new ReadDirRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreatePathRequest$Type extends MessageType<CreatePathRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreatePathRequest", [
            { no: 1, name: "endpoint_filepath", kind: "message", T: () => EndpointFilepath }
        ]);
    }
    create(value?: PartialMessage<CreatePathRequest>): CreatePathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreatePathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreatePathRequest): CreatePathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointFilepath endpoint_filepath */ 1:
                    message.endpointFilepath = EndpointFilepath.internalBinaryRead(reader, reader.uint32(), options, message.endpointFilepath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreatePathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointFilepath endpoint_filepath = 1; */
        if (message.endpointFilepath)
            EndpointFilepath.internalBinaryWrite(message.endpointFilepath, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreatePathRequest
 */
export const CreatePathRequest = new CreatePathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrashPathRequest$Type extends MessageType<TrashPathRequest> {
    constructor() {
        super("portola.spyder.api.v1.TrashPathRequest", [
            { no: 1, name: "endpoint_filepath", kind: "message", T: () => EndpointFilepath }
        ]);
    }
    create(value?: PartialMessage<TrashPathRequest>): TrashPathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrashPathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrashPathRequest): TrashPathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointFilepath endpoint_filepath */ 1:
                    message.endpointFilepath = EndpointFilepath.internalBinaryRead(reader, reader.uint32(), options, message.endpointFilepath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrashPathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointFilepath endpoint_filepath = 1; */
        if (message.endpointFilepath)
            EndpointFilepath.internalBinaryWrite(message.endpointFilepath, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.TrashPathRequest
 */
export const TrashPathRequest = new TrashPathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenamePathRequest$Type extends MessageType<RenamePathRequest> {
    constructor() {
        super("portola.spyder.api.v1.RenamePathRequest", [
            { no: 1, name: "endpoint_filepath", kind: "message", T: () => EndpointFilepath },
            { no: 2, name: "new_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RenamePathRequest>): RenamePathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newPath = "";
        if (value !== undefined)
            reflectionMergePartial<RenamePathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenamePathRequest): RenamePathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointFilepath endpoint_filepath */ 1:
                    message.endpointFilepath = EndpointFilepath.internalBinaryRead(reader, reader.uint32(), options, message.endpointFilepath);
                    break;
                case /* string new_path */ 2:
                    message.newPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenamePathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointFilepath endpoint_filepath = 1; */
        if (message.endpointFilepath)
            EndpointFilepath.internalBinaryWrite(message.endpointFilepath, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string new_path = 2; */
        if (message.newPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.RenamePathRequest
 */
export const RenamePathRequest = new RenamePathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyPathRequest$Type extends MessageType<CopyPathRequest> {
    constructor() {
        super("portola.spyder.api.v1.CopyPathRequest", [
            { no: 2, name: "tunnel_locator", kind: "message", T: () => TunnelLocator },
            { no: 4, name: "server_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "client_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_upload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CopyPathRequest>): CopyPathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverPath = "";
        message.clientPath = "";
        message.isUpload = false;
        if (value !== undefined)
            reflectionMergePartial<CopyPathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CopyPathRequest): CopyPathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.TunnelLocator tunnel_locator */ 2:
                    message.tunnelLocator = TunnelLocator.internalBinaryRead(reader, reader.uint32(), options, message.tunnelLocator);
                    break;
                case /* string server_path */ 4:
                    message.serverPath = reader.string();
                    break;
                case /* string client_path */ 5:
                    message.clientPath = reader.string();
                    break;
                case /* bool is_upload */ 6:
                    message.isUpload = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CopyPathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.TunnelLocator tunnel_locator = 2; */
        if (message.tunnelLocator)
            TunnelLocator.internalBinaryWrite(message.tunnelLocator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string server_path = 4; */
        if (message.serverPath !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serverPath);
        /* string client_path = 5; */
        if (message.clientPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.clientPath);
        /* bool is_upload = 6; */
        if (message.isUpload !== false)
            writer.tag(6, WireType.Varint).bool(message.isUpload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CopyPathRequest
 */
export const CopyPathRequest = new CopyPathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppConfig$Type extends MessageType<AppConfig> {
    constructor() {
        super("portola.spyder.api.v1.AppConfig", [
            { no: 1, name: "base_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tls_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "tls_skip_verify", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AppConfig>): AppConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.baseUrl = "";
        message.tlsEnabled = false;
        message.tlsSkipVerify = false;
        if (value !== undefined)
            reflectionMergePartial<AppConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppConfig): AppConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base_url */ 1:
                    message.baseUrl = reader.string();
                    break;
                case /* bool tls_enabled */ 2:
                    message.tlsEnabled = reader.bool();
                    break;
                case /* bool tls_skip_verify */ 3:
                    message.tlsSkipVerify = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base_url = 1; */
        if (message.baseUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.baseUrl);
        /* bool tls_enabled = 2; */
        if (message.tlsEnabled !== false)
            writer.tag(2, WireType.Varint).bool(message.tlsEnabled);
        /* bool tls_skip_verify = 3; */
        if (message.tlsSkipVerify !== false)
            writer.tag(3, WireType.Varint).bool(message.tlsSkipVerify);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.AppConfig
 */
export const AppConfig = new AppConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointConfig$Type extends MessageType<EndpointConfig> {
    constructor() {
        super("portola.spyder.api.v1.EndpointConfig", [
            { no: 1, name: "endpoint_service_config", kind: "message", T: () => AppConfig }
        ]);
    }
    create(value?: PartialMessage<EndpointConfig>): EndpointConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EndpointConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointConfig): EndpointConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.spyder.api.v1.AppConfig endpoint_service_config */ 1:
                    message.endpointServiceConfig = AppConfig.internalBinaryRead(reader, reader.uint32(), options, message.endpointServiceConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.spyder.api.v1.AppConfig endpoint_service_config = 1; */
        if (message.endpointServiceConfig)
            AppConfig.internalBinaryWrite(message.endpointServiceConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.EndpointConfig
 */
export const EndpointConfig = new EndpointConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpgradeEndpointRequest$Type extends MessageType<UpgradeEndpointRequest> {
    constructor() {
        super("portola.spyder.api.v1.UpgradeEndpointRequest", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "desired_version", kind: "message", T: () => SemanticVersion }
        ]);
    }
    create(value?: PartialMessage<UpgradeEndpointRequest>): UpgradeEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpgradeEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpgradeEndpointRequest): UpgradeEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* portola.common.api.v1.SemanticVersion desired_version */ 2:
                    message.desiredVersion = SemanticVersion.internalBinaryRead(reader, reader.uint32(), options, message.desiredVersion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpgradeEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.SemanticVersion desired_version = 2; */
        if (message.desiredVersion)
            SemanticVersion.internalBinaryWrite(message.desiredVersion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.UpgradeEndpointRequest
 */
export const UpgradeEndpointRequest = new UpgradeEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaffeinateEndpointRequest$Type extends MessageType<CaffeinateEndpointRequest> {
    constructor() {
        super("portola.spyder.api.v1.CaffeinateEndpointRequest", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "is_caffeinated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CaffeinateEndpointRequest>): CaffeinateEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isCaffeinated = false;
        if (value !== undefined)
            reflectionMergePartial<CaffeinateEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaffeinateEndpointRequest): CaffeinateEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* bool is_caffeinated */ 2:
                    message.isCaffeinated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaffeinateEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_caffeinated = 2; */
        if (message.isCaffeinated !== false)
            writer.tag(2, WireType.Varint).bool(message.isCaffeinated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CaffeinateEndpointRequest
 */
export const CaffeinateEndpointRequest = new CaffeinateEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertificateSigningRequest$Type extends MessageType<CertificateSigningRequest> {
    constructor() {
        super("portola.spyder.api.v1.CertificateSigningRequest", [
            { no: 1, name: "csr", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CertificateSigningRequest>): CertificateSigningRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.csr = "";
        if (value !== undefined)
            reflectionMergePartial<CertificateSigningRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertificateSigningRequest): CertificateSigningRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string csr */ 1:
                    message.csr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertificateSigningRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string csr = 1; */
        if (message.csr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.csr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CertificateSigningRequest
 */
export const CertificateSigningRequest = new CertificateSigningRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Certificate$Type extends MessageType<Certificate> {
    constructor() {
        super("portola.spyder.api.v1.Certificate", [
            { no: 2, name: "cert", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Certificate>): Certificate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cert = "";
        if (value !== undefined)
            reflectionMergePartial<Certificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Certificate): Certificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cert */ 2:
                    message.cert = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Certificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cert = 2; */
        if (message.cert !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cert);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.Certificate
 */
export const Certificate = new Certificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointStatus$Type extends MessageType<EndpointStatus> {
    constructor() {
        super("portola.spyder.api.v1.EndpointStatus", [
            { no: 1, name: "status_enum", kind: "enum", T: () => ["portola.spyder.api.v1.StatusEnum", StatusEnum] },
            { no: 2, name: "last_online_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "is_caffeinated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EndpointStatus>): EndpointStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusEnum = 0;
        message.lastOnlineSec = 0n;
        message.isCaffeinated = false;
        if (value !== undefined)
            reflectionMergePartial<EndpointStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointStatus): EndpointStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.spyder.api.v1.StatusEnum status_enum */ 1:
                    message.statusEnum = reader.int32();
                    break;
                case /* int64 last_online_sec */ 2:
                    message.lastOnlineSec = reader.int64().toBigInt();
                    break;
                case /* bool is_caffeinated */ 3:
                    message.isCaffeinated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.spyder.api.v1.StatusEnum status_enum = 1; */
        if (message.statusEnum !== 0)
            writer.tag(1, WireType.Varint).int32(message.statusEnum);
        /* int64 last_online_sec = 2; */
        if (message.lastOnlineSec !== 0n)
            writer.tag(2, WireType.Varint).int64(message.lastOnlineSec);
        /* bool is_caffeinated = 3; */
        if (message.isCaffeinated !== false)
            writer.tag(3, WireType.Varint).bool(message.isCaffeinated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.EndpointStatus
 */
export const EndpointStatus = new EndpointStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishHubRequest$Type extends MessageType<PublishHubRequest> {
    constructor() {
        super("portola.spyder.api.v1.PublishHubRequest", [
            { no: 1, name: "hub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_locator_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EndpointLocator }
        ]);
    }
    create(value?: PartialMessage<PublishHubRequest>): PublishHubRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hub = "";
        message.endpointLocatorList = [];
        if (value !== undefined)
            reflectionMergePartial<PublishHubRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishHubRequest): PublishHubRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hub */ 1:
                    message.hub = reader.string();
                    break;
                case /* repeated portola.common.api.v1.EndpointLocator endpoint_locator_list */ 2:
                    message.endpointLocatorList.push(EndpointLocator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishHubRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hub = 1; */
        if (message.hub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hub);
        /* repeated portola.common.api.v1.EndpointLocator endpoint_locator_list = 2; */
        for (let i = 0; i < message.endpointLocatorList.length; i++)
            EndpointLocator.internalBinaryWrite(message.endpointLocatorList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.PublishHubRequest
 */
export const PublishHubRequest = new PublishHubRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnpublishHubRequest$Type extends MessageType<UnpublishHubRequest> {
    constructor() {
        super("portola.spyder.api.v1.UnpublishHubRequest", [
            { no: 1, name: "hub", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnpublishHubRequest>): UnpublishHubRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hub = "";
        if (value !== undefined)
            reflectionMergePartial<UnpublishHubRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnpublishHubRequest): UnpublishHubRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hub */ 1:
                    message.hub = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnpublishHubRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hub = 1; */
        if (message.hub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hub);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.UnpublishHubRequest
 */
export const UnpublishHubRequest = new UnpublishHubRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishEndpointRequest$Type extends MessageType<PublishEndpointRequest> {
    constructor() {
        super("portola.spyder.api.v1.PublishEndpointRequest", [
            { no: 1, name: "hub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_locator", kind: "message", T: () => EndpointLocator }
        ]);
    }
    create(value?: PartialMessage<PublishEndpointRequest>): PublishEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hub = "";
        if (value !== undefined)
            reflectionMergePartial<PublishEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishEndpointRequest): PublishEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hub */ 1:
                    message.hub = reader.string();
                    break;
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 2:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hub = 1; */
        if (message.hub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hub);
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 2; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.PublishEndpointRequest
 */
export const PublishEndpointRequest = new PublishEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnpublishEndpointRequest$Type extends MessageType<UnpublishEndpointRequest> {
    constructor() {
        super("portola.spyder.api.v1.UnpublishEndpointRequest", [
            { no: 1, name: "hub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_locator", kind: "message", T: () => EndpointLocator }
        ]);
    }
    create(value?: PartialMessage<UnpublishEndpointRequest>): UnpublishEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hub = "";
        if (value !== undefined)
            reflectionMergePartial<UnpublishEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnpublishEndpointRequest): UnpublishEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hub */ 1:
                    message.hub = reader.string();
                    break;
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 2:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnpublishEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hub = 1; */
        if (message.hub !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hub);
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 2; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.UnpublishEndpointRequest
 */
export const UnpublishEndpointRequest = new UnpublishEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTunnelRequest$Type extends MessageType<CreateTunnelRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateTunnelRequest", [
            { no: 1, name: "left_connector", kind: "message", T: () => Connector },
            { no: 2, name: "right_connector", kind: "message", T: () => Connector }
        ]);
    }
    create(value?: PartialMessage<CreateTunnelRequest>): CreateTunnelRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateTunnelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTunnelRequest): CreateTunnelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.Connector left_connector */ 1:
                    message.leftConnector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.leftConnector);
                    break;
                case /* portola.common.api.v1.Connector right_connector */ 2:
                    message.rightConnector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.rightConnector);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTunnelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.Connector left_connector = 1; */
        if (message.leftConnector)
            Connector.internalBinaryWrite(message.leftConnector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Connector right_connector = 2; */
        if (message.rightConnector)
            Connector.internalBinaryWrite(message.rightConnector, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateTunnelRequest
 */
export const CreateTunnelRequest = new CreateTunnelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTunnelFromExportRequest$Type extends MessageType<CreateTunnelFromExportRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateTunnelFromExportRequest", [
            { no: 1, name: "right_connector", kind: "message", T: () => Connector },
            { no: 2, name: "connector_export_locator", kind: "message", T: () => ConnectorExportLocator }
        ]);
    }
    create(value?: PartialMessage<CreateTunnelFromExportRequest>): CreateTunnelFromExportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateTunnelFromExportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTunnelFromExportRequest): CreateTunnelFromExportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.Connector right_connector */ 1:
                    message.rightConnector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.rightConnector);
                    break;
                case /* portola.common.api.v1.ConnectorExportLocator connector_export_locator */ 2:
                    message.connectorExportLocator = ConnectorExportLocator.internalBinaryRead(reader, reader.uint32(), options, message.connectorExportLocator);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTunnelFromExportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.Connector right_connector = 1; */
        if (message.rightConnector)
            Connector.internalBinaryWrite(message.rightConnector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.ConnectorExportLocator connector_export_locator = 2; */
        if (message.connectorExportLocator)
            ConnectorExportLocator.internalBinaryWrite(message.connectorExportLocator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateTunnelFromExportRequest
 */
export const CreateTunnelFromExportRequest = new CreateTunnelFromExportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllConnectorExportsFromMeRequest$Type extends MessageType<GetAllConnectorExportsFromMeRequest> {
    constructor() {
        super("portola.spyder.api.v1.GetAllConnectorExportsFromMeRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "connector_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllConnectorExportsFromMeRequest>): GetAllConnectorExportsFromMeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.endpointId = "";
        message.connectorId = "";
        if (value !== undefined)
            reflectionMergePartial<GetAllConnectorExportsFromMeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllConnectorExportsFromMeRequest): GetAllConnectorExportsFromMeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string endpoint_id */ 2:
                    message.endpointId = reader.string();
                    break;
                case /* string connector_id */ 3:
                    message.connectorId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllConnectorExportsFromMeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string endpoint_id = 2; */
        if (message.endpointId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpointId);
        /* string connector_id = 3; */
        if (message.connectorId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.connectorId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.GetAllConnectorExportsFromMeRequest
 */
export const GetAllConnectorExportsFromMeRequest = new GetAllConnectorExportsFromMeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindTunnelsRequest$Type extends MessageType<FindTunnelsRequest> {
    constructor() {
        super("portola.spyder.api.v1.FindTunnelsRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FindTunnelsRequest>): FindTunnelsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.endpointId = "";
        if (value !== undefined)
            reflectionMergePartial<FindTunnelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindTunnelsRequest): FindTunnelsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string endpoint_id */ 2:
                    message.endpointId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindTunnelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string endpoint_id = 2; */
        if (message.endpointId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.FindTunnelsRequest
 */
export const FindTunnelsRequest = new FindTunnelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateConnectorExportRequest$Type extends MessageType<CreateConnectorExportRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateConnectorExportRequest", [
            { no: 1, name: "left_connector", kind: "message", T: () => Connector },
            { no: 2, name: "connector_access_control", kind: "message", T: () => ConnectorAccessControl }
        ]);
    }
    create(value?: PartialMessage<CreateConnectorExportRequest>): CreateConnectorExportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateConnectorExportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateConnectorExportRequest): CreateConnectorExportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.Connector left_connector */ 1:
                    message.leftConnector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.leftConnector);
                    break;
                case /* portola.spyder.api.v1.ConnectorAccessControl connector_access_control */ 2:
                    message.connectorAccessControl = ConnectorAccessControl.internalBinaryRead(reader, reader.uint32(), options, message.connectorAccessControl);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateConnectorExportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.Connector left_connector = 1; */
        if (message.leftConnector)
            Connector.internalBinaryWrite(message.leftConnector, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.spyder.api.v1.ConnectorAccessControl connector_access_control = 2; */
        if (message.connectorAccessControl)
            ConnectorAccessControl.internalBinaryWrite(message.connectorAccessControl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateConnectorExportRequest
 */
export const CreateConnectorExportRequest = new CreateConnectorExportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectorAccessControl$Type extends MessageType<ConnectorAccessControl> {
    constructor() {
        super("portola.spyder.api.v1.ConnectorAccessControl", [
            { no: 1, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectorAccessControl>): ConnectorAccessControl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.email = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectorAccessControl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectorAccessControl): ConnectorAccessControl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userId */ 1:
                    message.userId = reader.string();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectorAccessControl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userId = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.ConnectorAccessControl
 */
export const ConnectorAccessControl = new ConnectorAccessControl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectorExport$Type extends MessageType<ConnectorExport> {
    constructor() {
        super("portola.spyder.api.v1.ConnectorExport", [
            { no: 1, name: "connector_export_locator", kind: "message", T: () => ConnectorExportLocator },
            { no: 2, name: "connector", kind: "message", T: () => Connector },
            { no: 3, name: "connector_access_control", kind: "message", T: () => ConnectorAccessControl },
            { no: 4, name: "from_user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<ConnectorExport>): ConnectorExport {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConnectorExport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectorExport): ConnectorExport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.ConnectorExportLocator connector_export_locator */ 1:
                    message.connectorExportLocator = ConnectorExportLocator.internalBinaryRead(reader, reader.uint32(), options, message.connectorExportLocator);
                    break;
                case /* portola.common.api.v1.Connector connector */ 2:
                    message.connector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.connector);
                    break;
                case /* portola.spyder.api.v1.ConnectorAccessControl connector_access_control */ 3:
                    message.connectorAccessControl = ConnectorAccessControl.internalBinaryRead(reader, reader.uint32(), options, message.connectorAccessControl);
                    break;
                case /* portola.spyder.api.v1.User from_user */ 4:
                    message.fromUser = User.internalBinaryRead(reader, reader.uint32(), options, message.fromUser);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectorExport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.ConnectorExportLocator connector_export_locator = 1; */
        if (message.connectorExportLocator)
            ConnectorExportLocator.internalBinaryWrite(message.connectorExportLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Connector connector = 2; */
        if (message.connector)
            Connector.internalBinaryWrite(message.connector, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* portola.spyder.api.v1.ConnectorAccessControl connector_access_control = 3; */
        if (message.connectorAccessControl)
            ConnectorAccessControl.internalBinaryWrite(message.connectorAccessControl, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* portola.spyder.api.v1.User from_user = 4; */
        if (message.fromUser)
            User.internalBinaryWrite(message.fromUser, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.ConnectorExport
 */
export const ConnectorExport = new ConnectorExport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectorExportList$Type extends MessageType<ConnectorExportList> {
    constructor() {
        super("portola.spyder.api.v1.ConnectorExportList", [
            { no: 1, name: "connector_export_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConnectorExport }
        ]);
    }
    create(value?: PartialMessage<ConnectorExportList>): ConnectorExportList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorExportList = [];
        if (value !== undefined)
            reflectionMergePartial<ConnectorExportList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectorExportList): ConnectorExportList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated portola.spyder.api.v1.ConnectorExport connector_export_list */ 1:
                    message.connectorExportList.push(ConnectorExport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectorExportList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated portola.spyder.api.v1.ConnectorExport connector_export_list = 1; */
        for (let i = 0; i < message.connectorExportList.length; i++)
            ConnectorExport.internalBinaryWrite(message.connectorExportList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.ConnectorExportList
 */
export const ConnectorExportList = new ConnectorExportList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserRequest$Type extends MessageType<CreateUserRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateUserRequest", []);
    }
    create(value?: PartialMessage<CreateUserRequest>): CreateUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserRequest): CreateUserRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CreateUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateUserRequest
 */
export const CreateUserRequest = new CreateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateClientRequest$Type extends MessageType<CreateClientRequest> {
    constructor() {
        super("portola.spyder.api.v1.CreateClientRequest", [
            { no: 1, name: "endpoint_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateClientRequest>): CreateClientRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpointId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateClientRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateClientRequest): CreateClientRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string endpoint_id */ 1:
                    message.endpointId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateClientRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string endpoint_id = 1; */
        if (message.endpointId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.endpointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.CreateClientRequest
 */
export const CreateClientRequest = new CreateClientRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("portola.spyder.api.v1.User", [
            { no: 1, name: "user_locator", kind: "message", T: () => UserLocator },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "email_verified", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "picture", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "firebase", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.email = "";
        message.emailVerified = false;
        message.picture = "";
        message.firebase = "";
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.UserLocator user_locator */ 1:
                    message.userLocator = UserLocator.internalBinaryRead(reader, reader.uint32(), options, message.userLocator);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* bool email_verified */ 4:
                    message.emailVerified = reader.bool();
                    break;
                case /* string picture */ 5:
                    message.picture = reader.string();
                    break;
                case /* string firebase */ 6:
                    message.firebase = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.UserLocator user_locator = 1; */
        if (message.userLocator)
            UserLocator.internalBinaryWrite(message.userLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* bool email_verified = 4; */
        if (message.emailVerified !== false)
            writer.tag(4, WireType.Varint).bool(message.emailVerified);
        /* string picture = 5; */
        if (message.picture !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.picture);
        /* string firebase = 6; */
        if (message.firebase !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.firebase);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertEndpointRequest$Type extends MessageType<UpsertEndpointRequest> {
    constructor() {
        super("portola.spyder.api.v1.UpsertEndpointRequest", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "agent_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "agent_build_date", kind: "message", T: () => Timestamp },
            { no: 5, name: "homedir", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpsertEndpointRequest>): UpsertEndpointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.agentVersion = "";
        message.homedir = "";
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<UpsertEndpointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertEndpointRequest): UpsertEndpointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string agent_version */ 3:
                    message.agentVersion = reader.string();
                    break;
                case /* google.protobuf.Timestamp agent_build_date */ 4:
                    message.agentBuildDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.agentBuildDate);
                    break;
                case /* string homedir */ 5:
                    message.homedir = reader.string();
                    break;
                case /* string username */ 6:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertEndpointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string agent_version = 3; */
        if (message.agentVersion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.agentVersion);
        /* google.protobuf.Timestamp agent_build_date = 4; */
        if (message.agentBuildDate)
            Timestamp.internalBinaryWrite(message.agentBuildDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string homedir = 5; */
        if (message.homedir !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.homedir);
        /* string username = 6; */
        if (message.username !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.UpsertEndpointRequest
 */
export const UpsertEndpointRequest = new UpsertEndpointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint$Type extends MessageType<Endpoint> {
    constructor() {
        super("portola.spyder.api.v1.Endpoint", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "agent_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "agent_build_date", kind: "message", T: () => Timestamp },
            { no: 5, name: "homedir", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Endpoint>): Endpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.agentVersion = "";
        message.homedir = "";
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<Endpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint): Endpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string agent_version */ 3:
                    message.agentVersion = reader.string();
                    break;
                case /* google.protobuf.Timestamp agent_build_date */ 4:
                    message.agentBuildDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.agentBuildDate);
                    break;
                case /* string homedir */ 5:
                    message.homedir = reader.string();
                    break;
                case /* string username */ 6:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string agent_version = 3; */
        if (message.agentVersion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.agentVersion);
        /* google.protobuf.Timestamp agent_build_date = 4; */
        if (message.agentBuildDate)
            Timestamp.internalBinaryWrite(message.agentBuildDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string homedir = 5; */
        if (message.homedir !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.homedir);
        /* string username = 6; */
        if (message.username !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.Endpoint
 */
export const Endpoint = new Endpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointList$Type extends MessageType<EndpointList> {
    constructor() {
        super("portola.spyder.api.v1.EndpointList", [
            { no: 1, name: "endpoint_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint }
        ]);
    }
    create(value?: PartialMessage<EndpointList>): EndpointList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpointList = [];
        if (value !== undefined)
            reflectionMergePartial<EndpointList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointList): EndpointList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated portola.spyder.api.v1.Endpoint endpoint_list */ 1:
                    message.endpointList.push(Endpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated portola.spyder.api.v1.Endpoint endpoint_list = 1; */
        for (let i = 0; i < message.endpointList.length; i++)
            Endpoint.internalBinaryWrite(message.endpointList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.spyder.api.v1.EndpointList
 */
export const EndpointList = new EndpointList$Type();
/**
 * @generated ServiceType for protobuf service portola.spyder.api.v1.SpyderService
 */
export const SpyderService = new ServiceType("portola.spyder.api.v1.SpyderService", [
    { name: "CheckHealth", options: {}, I: Empty, O: GrpcResponse },
    { name: "ImpersonateUser", options: {}, I: UserLocator, O: User },
    { name: "CreateUser", options: {}, I: CreateUserRequest, O: User },
    { name: "GetUser", options: {}, I: UserLocator, O: User },
    { name: "CreateChat", options: {}, I: CreateChatRequet, O: Chat },
    { name: "GetAllChat", options: {}, I: GetAllChatRequest, O: ChatList },
    { name: "DeleteChat", options: {}, I: ChatLocator, O: Empty },
    { name: "CreateClient", options: {}, I: CreateClientRequest, O: Client },
    { name: "DeleteClient", options: {}, I: Client, O: Empty },
    { name: "GetAllClients", options: {}, I: UserLocator, O: ClientList },
    { name: "UpsertEndpoint", options: {}, I: UpsertEndpointRequest, O: Endpoint },
    { name: "GetEndpoint", options: {}, I: EndpointLocator, O: Endpoint },
    { name: "GetAllEndpoints", options: {}, I: UserLocator, O: EndpointList },
    { name: "UpsertPublicKey", options: {}, I: UpsertPublicKeyRequest, O: Empty },
    { name: "GetPublicKey", options: {}, I: GetPublicKeyRequest, O: PublicKey },
    { name: "CreateTunnel", options: {}, I: CreateTunnelRequest, O: Tunnel },
    { name: "DeleteTunnel", options: {}, I: TunnelLocator, O: Empty },
    { name: "GetAllTunnels", options: {}, I: UserLocator, O: TunnelList },
    { name: "FindTunnels", options: {}, I: FindTunnelsRequest, O: TunnelList },
    { name: "GetTunnel", options: {}, I: TunnelLocator, O: Tunnel },
    { name: "CreateConnectorExport", options: {}, I: CreateConnectorExportRequest, O: ConnectorExport },
    { name: "CreateTunnelFromExport", options: {}, I: CreateTunnelFromExportRequest, O: Tunnel },
    { name: "GetAllConnectorExportsFromMe", options: {}, I: GetAllConnectorExportsFromMeRequest, O: ConnectorExportList },
    { name: "GetAllConnectorExportsToMe", options: {}, I: UserLocator, O: ConnectorExportList },
    { name: "DeleteConnectorExport", options: {}, I: ConnectorExportLocator, O: Empty },
    { name: "GetEndpointStatus", options: {}, I: EndpointLocator, O: EndpointStatus },
    { name: "GenerateSingedCert", options: {}, I: CertificateSigningRequest, O: Certificate },
    { name: "CaffeinateEndpoint", options: {}, I: CaffeinateEndpointRequest, O: Empty },
    { name: "FsReadDir", options: {}, I: ReadDirRequest, O: DirListing },
    { name: "FsCreatePath", options: {}, I: CreatePathRequest, O: Empty },
    { name: "FsTrashPath", options: {}, I: TrashPathRequest, O: Empty },
    { name: "FsRenamePath", options: {}, I: RenamePathRequest, O: Empty },
    { name: "FsCopyPath", options: {}, I: CopyPathRequest, O: Empty },
    { name: "PutAuthData", options: {}, I: AuthDataRequest, O: RedemptionCode },
    { name: "RedeemAuthData", options: {}, I: RedeemAuthDataRequest, O: AuthData },
    { name: "GetEndpointConfig", options: {}, I: EndpointLocator, O: EndpointConfig },
    { name: "CreateStripeCheckoutSession", options: {}, I: CreateStripeCheckoutSessionRequest, O: CreateStripeCheckoutSessionResponse },
    { name: "CreateStripePortalSession", options: {}, I: CreateStripePortalSessionRequest, O: CreateStripePortalSessionResponse },
    { name: "AuthenticateClient", options: {}, I: Client, O: Token }
]);

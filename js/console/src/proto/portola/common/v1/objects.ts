// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "portola/common/v1/objects.proto" (package "portola.common.api.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
/**
 * @generated from protobuf message portola.common.api.v1.Address
 */
export interface Address {
    /**
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * @generated from protobuf field: int32 port = 2;
     */
    port: number;
}
/**
 * @generated from protobuf message portola.common.api.v1.SshServer
 */
export interface SshServer {
    /**
     * @generated from protobuf field: portola.common.api.v1.AuthAccess auth_access = 1;
     */
    authAccess?: AuthAccess;
}
/**
 * @generated from protobuf message portola.common.api.v1.SftpServer
 */
export interface SftpServer {
    /**
     * @generated from protobuf field: portola.common.api.v1.PathAccess path_access = 1;
     */
    pathAccess?: PathAccess;
    /**
     * @generated from protobuf field: portola.common.api.v1.AuthAccess auth_access = 2;
     */
    authAccess?: AuthAccess;
}
/**
 * @generated from protobuf message portola.common.api.v1.PathAccess
 */
export interface PathAccess {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: portola.common.api.v1.AccessEnum access_enum = 2;
     */
    accessEnum: AccessEnum;
}
/**
 * @generated from protobuf message portola.common.api.v1.AuthAccess
 */
export interface AuthAccess {
    /**
     * @generated from protobuf field: portola.common.api.v1.AuthEnum auth_enum = 1;
     */
    authEnum: AuthEnum;
}
/**
 * @generated from protobuf message portola.common.api.v1.SftpClient
 */
export interface SftpClient {
}
/**
 * @generated from protobuf message portola.common.api.v1.Connector
 */
export interface Connector {
    /**
     * ConnectorLocator connector_locator = 1;
     *
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf oneof: connector_type
     */
    connectorType: {
        oneofKind: "tcpServer";
        /**
         * @generated from protobuf field: portola.common.api.v1.Address tcp_server = 2;
         */
        tcpServer: Address;
    } | {
        oneofKind: "tcpClient";
        /**
         * @generated from protobuf field: portola.common.api.v1.Address tcp_client = 3;
         */
        tcpClient: Address;
    } | {
        oneofKind: "sftpServer";
        /**
         * @generated from protobuf field: portola.common.api.v1.SftpServer sftp_server = 4;
         */
        sftpServer: SftpServer;
    } | {
        oneofKind: "sftpClient";
        /**
         * @generated from protobuf field: portola.common.api.v1.SftpClient sftp_client = 5;
         */
        sftpClient: SftpClient;
    } | {
        oneofKind: "sshServer";
        /**
         * @generated from protobuf field: portola.common.api.v1.SshServer ssh_server = 6;
         */
        sshServer: SshServer;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message portola.common.api.v1.TunnelLocator
 */
export interface TunnelLocator {
    /**
     * @generated from protobuf field: string tunnel_id = 1;
     */
    tunnelId: string;
}
/**
 * @generated from protobuf message portola.common.api.v1.UserLocator
 */
export interface UserLocator {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
}
/**
 * @generated from protobuf message portola.common.api.v1.EndpointLocator
 */
export interface EndpointLocator {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string endpoint_id = 2;
     */
    endpointId: string;
}
/**
 * @generated from protobuf message portola.common.api.v1.ChatLocator
 */
export interface ChatLocator {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string chat_id = 2;
     */
    chatId: string;
}
/**
 * @generated from protobuf message portola.common.api.v1.ConnectorExportLocator
 */
export interface ConnectorExportLocator {
    /**
     * @generated from protobuf field: string connector_export_id = 1;
     */
    connectorExportId: string;
}
/**
 * SemanticVersion represents a semantic version.
 *
 * @generated from protobuf message portola.common.api.v1.SemanticVersion
 */
export interface SemanticVersion {
    /**
     * @generated from protobuf field: uint32 major = 1;
     */
    major: number;
    /**
     * @generated from protobuf field: uint32 minor = 2;
     */
    minor: number;
    /**
     * @generated from protobuf field: uint32 patch = 3;
     */
    patch: number;
}
// 

/**
 * @generated from protobuf message portola.common.api.v1.TunnelConnector
 */
export interface TunnelConnector {
    /**
     * @generated from protobuf field: string tunnel_id = 1;
     */
    tunnelId: string;
    /**
     * @generated from protobuf field: portola.common.api.v1.Address tunnel_server = 2;
     */
    tunnelServer?: Address;
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector connector = 3;
     */
    connector?: Connector;
}
// FS

/**
 * @generated from protobuf message portola.common.api.v1.DirListing
 */
export interface DirListing {
    /**
     * @generated from protobuf field: repeated portola.common.api.v1.FileInfo file_info_arr = 1;
     */
    fileInfoArr: FileInfo[];
}
/**
 * @generated from protobuf message portola.common.api.v1.EndpointFilepath
 */
export interface EndpointFilepath {
    /**
     * @generated from protobuf field: portola.common.api.v1.EndpointLocator endpoint_locator = 1;
     */
    endpointLocator?: EndpointLocator;
    /**
     * @generated from protobuf field: string path = 2;
     */
    path: string;
}
/**
 * @generated from protobuf message portola.common.api.v1.FileInfo
 */
export interface FileInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string; // base name of the file
    /**
     * @generated from protobuf field: int64 size = 2;
     */
    size: bigint; // length in bytes for regular files; system-dependent for others
    /**
     * @generated from protobuf field: uint32 file_mode = 3;
     */
    fileMode: number; // file mode bits
    /**
     * @generated from protobuf field: google.protobuf.Timestamp mod_time = 4;
     */
    modTime?: Timestamp; // modification time
    /**
     * @generated from protobuf field: bool is_dir = 5;
     */
    isDir: boolean; // abbreviation for Mode().IsDir()
}
/**
 * @generated from protobuf message portola.common.api.v1.Tunnel
 */
export interface Tunnel {
    /**
     * @generated from protobuf field: portola.common.api.v1.TunnelLocator tunnel_locator = 1;
     */
    tunnelLocator?: TunnelLocator;
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector left_connector = 2;
     */
    leftConnector?: Connector;
    /**
     * @generated from protobuf field: portola.common.api.v1.Connector right_connector = 3;
     */
    rightConnector?: Connector;
}
/**
 * @generated from protobuf message portola.common.api.v1.TunnelList
 */
export interface TunnelList {
    /**
     * @generated from protobuf field: repeated portola.common.api.v1.Tunnel tunnel_list = 1;
     */
    tunnelList: Tunnel[];
}
/**
 * @generated from protobuf enum portola.common.api.v1.AuthEnum
 */
export enum AuthEnum {
    /**
     * @generated from protobuf enum value: AUTH_NONE = 0;
     */
    AUTH_NONE = 0,
    /**
     * @generated from protobuf enum value: AUTH_USER_PASSWORD = 1;
     */
    AUTH_USER_PASSWORD = 1,
    /**
     * @generated from protobuf enum value: AUTH_USER_PUBLICKEY = 2;
     */
    AUTH_USER_PUBLICKEY = 2,
    /**
     * @generated from protobuf enum value: AUTH_CERT = 3;
     */
    AUTH_CERT = 3
}
/**
 * @generated from protobuf enum portola.common.api.v1.AccessEnum
 */
export enum AccessEnum {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: READ_ONLY = 1;
     */
    READ_ONLY = 1,
    /**
     * @generated from protobuf enum value: READ_WRITE = 2;
     */
    READ_WRITE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Address$Type extends MessageType<Address> {
    constructor() {
        super("portola.common.api.v1.Address", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Address>): Address {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<Address>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Address): Address {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Address, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.Address
 */
export const Address = new Address$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SshServer$Type extends MessageType<SshServer> {
    constructor() {
        super("portola.common.api.v1.SshServer", [
            { no: 1, name: "auth_access", kind: "message", T: () => AuthAccess }
        ]);
    }
    create(value?: PartialMessage<SshServer>): SshServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SshServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SshServer): SshServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.AuthAccess auth_access */ 1:
                    message.authAccess = AuthAccess.internalBinaryRead(reader, reader.uint32(), options, message.authAccess);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SshServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.AuthAccess auth_access = 1; */
        if (message.authAccess)
            AuthAccess.internalBinaryWrite(message.authAccess, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.SshServer
 */
export const SshServer = new SshServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SftpServer$Type extends MessageType<SftpServer> {
    constructor() {
        super("portola.common.api.v1.SftpServer", [
            { no: 1, name: "path_access", kind: "message", T: () => PathAccess },
            { no: 2, name: "auth_access", kind: "message", T: () => AuthAccess }
        ]);
    }
    create(value?: PartialMessage<SftpServer>): SftpServer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SftpServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SftpServer): SftpServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.PathAccess path_access */ 1:
                    message.pathAccess = PathAccess.internalBinaryRead(reader, reader.uint32(), options, message.pathAccess);
                    break;
                case /* portola.common.api.v1.AuthAccess auth_access */ 2:
                    message.authAccess = AuthAccess.internalBinaryRead(reader, reader.uint32(), options, message.authAccess);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SftpServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.PathAccess path_access = 1; */
        if (message.pathAccess)
            PathAccess.internalBinaryWrite(message.pathAccess, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.AuthAccess auth_access = 2; */
        if (message.authAccess)
            AuthAccess.internalBinaryWrite(message.authAccess, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.SftpServer
 */
export const SftpServer = new SftpServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathAccess$Type extends MessageType<PathAccess> {
    constructor() {
        super("portola.common.api.v1.PathAccess", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "access_enum", kind: "enum", T: () => ["portola.common.api.v1.AccessEnum", AccessEnum] }
        ]);
    }
    create(value?: PartialMessage<PathAccess>): PathAccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.accessEnum = 0;
        if (value !== undefined)
            reflectionMergePartial<PathAccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PathAccess): PathAccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* portola.common.api.v1.AccessEnum access_enum */ 2:
                    message.accessEnum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PathAccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* portola.common.api.v1.AccessEnum access_enum = 2; */
        if (message.accessEnum !== 0)
            writer.tag(2, WireType.Varint).int32(message.accessEnum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.PathAccess
 */
export const PathAccess = new PathAccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthAccess$Type extends MessageType<AuthAccess> {
    constructor() {
        super("portola.common.api.v1.AuthAccess", [
            { no: 1, name: "auth_enum", kind: "enum", T: () => ["portola.common.api.v1.AuthEnum", AuthEnum] }
        ]);
    }
    create(value?: PartialMessage<AuthAccess>): AuthAccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authEnum = 0;
        if (value !== undefined)
            reflectionMergePartial<AuthAccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthAccess): AuthAccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.AuthEnum auth_enum */ 1:
                    message.authEnum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthAccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.AuthEnum auth_enum = 1; */
        if (message.authEnum !== 0)
            writer.tag(1, WireType.Varint).int32(message.authEnum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.AuthAccess
 */
export const AuthAccess = new AuthAccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SftpClient$Type extends MessageType<SftpClient> {
    constructor() {
        super("portola.common.api.v1.SftpClient", []);
    }
    create(value?: PartialMessage<SftpClient>): SftpClient {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SftpClient>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SftpClient): SftpClient {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SftpClient, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.SftpClient
 */
export const SftpClient = new SftpClient$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Connector$Type extends MessageType<Connector> {
    constructor() {
        super("portola.common.api.v1.Connector", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "tcp_server", kind: "message", oneof: "connectorType", T: () => Address },
            { no: 3, name: "tcp_client", kind: "message", oneof: "connectorType", T: () => Address },
            { no: 4, name: "sftp_server", kind: "message", oneof: "connectorType", T: () => SftpServer },
            { no: 5, name: "sftp_client", kind: "message", oneof: "connectorType", T: () => SftpClient },
            { no: 6, name: "ssh_server", kind: "message", oneof: "connectorType", T: () => SshServer }
        ]);
    }
    create(value?: PartialMessage<Connector>): Connector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Connector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Connector): Connector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* portola.common.api.v1.Address tcp_server */ 2:
                    message.connectorType = {
                        oneofKind: "tcpServer",
                        tcpServer: Address.internalBinaryRead(reader, reader.uint32(), options, (message.connectorType as any).tcpServer)
                    };
                    break;
                case /* portola.common.api.v1.Address tcp_client */ 3:
                    message.connectorType = {
                        oneofKind: "tcpClient",
                        tcpClient: Address.internalBinaryRead(reader, reader.uint32(), options, (message.connectorType as any).tcpClient)
                    };
                    break;
                case /* portola.common.api.v1.SftpServer sftp_server */ 4:
                    message.connectorType = {
                        oneofKind: "sftpServer",
                        sftpServer: SftpServer.internalBinaryRead(reader, reader.uint32(), options, (message.connectorType as any).sftpServer)
                    };
                    break;
                case /* portola.common.api.v1.SftpClient sftp_client */ 5:
                    message.connectorType = {
                        oneofKind: "sftpClient",
                        sftpClient: SftpClient.internalBinaryRead(reader, reader.uint32(), options, (message.connectorType as any).sftpClient)
                    };
                    break;
                case /* portola.common.api.v1.SshServer ssh_server */ 6:
                    message.connectorType = {
                        oneofKind: "sshServer",
                        sshServer: SshServer.internalBinaryRead(reader, reader.uint32(), options, (message.connectorType as any).sshServer)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Connector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Address tcp_server = 2; */
        if (message.connectorType.oneofKind === "tcpServer")
            Address.internalBinaryWrite(message.connectorType.tcpServer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Address tcp_client = 3; */
        if (message.connectorType.oneofKind === "tcpClient")
            Address.internalBinaryWrite(message.connectorType.tcpClient, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.SftpServer sftp_server = 4; */
        if (message.connectorType.oneofKind === "sftpServer")
            SftpServer.internalBinaryWrite(message.connectorType.sftpServer, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.SftpClient sftp_client = 5; */
        if (message.connectorType.oneofKind === "sftpClient")
            SftpClient.internalBinaryWrite(message.connectorType.sftpClient, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.SshServer ssh_server = 6; */
        if (message.connectorType.oneofKind === "sshServer")
            SshServer.internalBinaryWrite(message.connectorType.sshServer, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.Connector
 */
export const Connector = new Connector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TunnelLocator$Type extends MessageType<TunnelLocator> {
    constructor() {
        super("portola.common.api.v1.TunnelLocator", [
            { no: 1, name: "tunnel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TunnelLocator>): TunnelLocator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tunnelId = "";
        if (value !== undefined)
            reflectionMergePartial<TunnelLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TunnelLocator): TunnelLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tunnel_id */ 1:
                    message.tunnelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TunnelLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tunnel_id = 1; */
        if (message.tunnelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tunnelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.TunnelLocator
 */
export const TunnelLocator = new TunnelLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserLocator$Type extends MessageType<UserLocator> {
    constructor() {
        super("portola.common.api.v1.UserLocator", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserLocator>): UserLocator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<UserLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserLocator): UserLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.UserLocator
 */
export const UserLocator = new UserLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointLocator$Type extends MessageType<EndpointLocator> {
    constructor() {
        super("portola.common.api.v1.EndpointLocator", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EndpointLocator>): EndpointLocator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.endpointId = "";
        if (value !== undefined)
            reflectionMergePartial<EndpointLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointLocator): EndpointLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string endpoint_id */ 2:
                    message.endpointId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string endpoint_id = 2; */
        if (message.endpointId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpointId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.EndpointLocator
 */
export const EndpointLocator = new EndpointLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatLocator$Type extends MessageType<ChatLocator> {
    constructor() {
        super("portola.common.api.v1.ChatLocator", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "chat_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChatLocator>): ChatLocator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.chatId = "";
        if (value !== undefined)
            reflectionMergePartial<ChatLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatLocator): ChatLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string chat_id */ 2:
                    message.chatId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string chat_id = 2; */
        if (message.chatId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chatId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.ChatLocator
 */
export const ChatLocator = new ChatLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectorExportLocator$Type extends MessageType<ConnectorExportLocator> {
    constructor() {
        super("portola.common.api.v1.ConnectorExportLocator", [
            { no: 1, name: "connector_export_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectorExportLocator>): ConnectorExportLocator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectorExportId = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectorExportLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectorExportLocator): ConnectorExportLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connector_export_id */ 1:
                    message.connectorExportId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectorExportLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connector_export_id = 1; */
        if (message.connectorExportId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectorExportId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.ConnectorExportLocator
 */
export const ConnectorExportLocator = new ConnectorExportLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SemanticVersion$Type extends MessageType<SemanticVersion> {
    constructor() {
        super("portola.common.api.v1.SemanticVersion", [
            { no: 1, name: "major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "patch", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SemanticVersion>): SemanticVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.major = 0;
        message.minor = 0;
        message.patch = 0;
        if (value !== undefined)
            reflectionMergePartial<SemanticVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SemanticVersion): SemanticVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 major */ 1:
                    message.major = reader.uint32();
                    break;
                case /* uint32 minor */ 2:
                    message.minor = reader.uint32();
                    break;
                case /* uint32 patch */ 3:
                    message.patch = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SemanticVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 major = 1; */
        if (message.major !== 0)
            writer.tag(1, WireType.Varint).uint32(message.major);
        /* uint32 minor = 2; */
        if (message.minor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.minor);
        /* uint32 patch = 3; */
        if (message.patch !== 0)
            writer.tag(3, WireType.Varint).uint32(message.patch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.SemanticVersion
 */
export const SemanticVersion = new SemanticVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TunnelConnector$Type extends MessageType<TunnelConnector> {
    constructor() {
        super("portola.common.api.v1.TunnelConnector", [
            { no: 1, name: "tunnel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tunnel_server", kind: "message", T: () => Address },
            { no: 3, name: "connector", kind: "message", T: () => Connector }
        ]);
    }
    create(value?: PartialMessage<TunnelConnector>): TunnelConnector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tunnelId = "";
        if (value !== undefined)
            reflectionMergePartial<TunnelConnector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TunnelConnector): TunnelConnector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tunnel_id */ 1:
                    message.tunnelId = reader.string();
                    break;
                case /* portola.common.api.v1.Address tunnel_server */ 2:
                    message.tunnelServer = Address.internalBinaryRead(reader, reader.uint32(), options, message.tunnelServer);
                    break;
                case /* portola.common.api.v1.Connector connector */ 3:
                    message.connector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.connector);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TunnelConnector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tunnel_id = 1; */
        if (message.tunnelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tunnelId);
        /* portola.common.api.v1.Address tunnel_server = 2; */
        if (message.tunnelServer)
            Address.internalBinaryWrite(message.tunnelServer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Connector connector = 3; */
        if (message.connector)
            Connector.internalBinaryWrite(message.connector, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.TunnelConnector
 */
export const TunnelConnector = new TunnelConnector$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DirListing$Type extends MessageType<DirListing> {
    constructor() {
        super("portola.common.api.v1.DirListing", [
            { no: 1, name: "file_info_arr", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FileInfo }
        ]);
    }
    create(value?: PartialMessage<DirListing>): DirListing {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileInfoArr = [];
        if (value !== undefined)
            reflectionMergePartial<DirListing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DirListing): DirListing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated portola.common.api.v1.FileInfo file_info_arr */ 1:
                    message.fileInfoArr.push(FileInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DirListing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated portola.common.api.v1.FileInfo file_info_arr = 1; */
        for (let i = 0; i < message.fileInfoArr.length; i++)
            FileInfo.internalBinaryWrite(message.fileInfoArr[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.DirListing
 */
export const DirListing = new DirListing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointFilepath$Type extends MessageType<EndpointFilepath> {
    constructor() {
        super("portola.common.api.v1.EndpointFilepath", [
            { no: 1, name: "endpoint_locator", kind: "message", T: () => EndpointLocator },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EndpointFilepath>): EndpointFilepath {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<EndpointFilepath>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointFilepath): EndpointFilepath {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.EndpointLocator endpoint_locator */ 1:
                    message.endpointLocator = EndpointLocator.internalBinaryRead(reader, reader.uint32(), options, message.endpointLocator);
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointFilepath, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.EndpointLocator endpoint_locator = 1; */
        if (message.endpointLocator)
            EndpointLocator.internalBinaryWrite(message.endpointLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.EndpointFilepath
 */
export const EndpointFilepath = new EndpointFilepath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileInfo$Type extends MessageType<FileInfo> {
    constructor() {
        super("portola.common.api.v1.FileInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "file_mode", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "mod_time", kind: "message", T: () => Timestamp },
            { no: 5, name: "is_dir", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FileInfo>): FileInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.size = 0n;
        message.fileMode = 0;
        message.isDir = false;
        if (value !== undefined)
            reflectionMergePartial<FileInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileInfo): FileInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int64 size */ 2:
                    message.size = reader.int64().toBigInt();
                    break;
                case /* uint32 file_mode */ 3:
                    message.fileMode = reader.uint32();
                    break;
                case /* google.protobuf.Timestamp mod_time */ 4:
                    message.modTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.modTime);
                    break;
                case /* bool is_dir */ 5:
                    message.isDir = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int64 size = 2; */
        if (message.size !== 0n)
            writer.tag(2, WireType.Varint).int64(message.size);
        /* uint32 file_mode = 3; */
        if (message.fileMode !== 0)
            writer.tag(3, WireType.Varint).uint32(message.fileMode);
        /* google.protobuf.Timestamp mod_time = 4; */
        if (message.modTime)
            Timestamp.internalBinaryWrite(message.modTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool is_dir = 5; */
        if (message.isDir !== false)
            writer.tag(5, WireType.Varint).bool(message.isDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.FileInfo
 */
export const FileInfo = new FileInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tunnel$Type extends MessageType<Tunnel> {
    constructor() {
        super("portola.common.api.v1.Tunnel", [
            { no: 1, name: "tunnel_locator", kind: "message", T: () => TunnelLocator },
            { no: 2, name: "left_connector", kind: "message", T: () => Connector },
            { no: 3, name: "right_connector", kind: "message", T: () => Connector }
        ]);
    }
    create(value?: PartialMessage<Tunnel>): Tunnel {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Tunnel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tunnel): Tunnel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* portola.common.api.v1.TunnelLocator tunnel_locator */ 1:
                    message.tunnelLocator = TunnelLocator.internalBinaryRead(reader, reader.uint32(), options, message.tunnelLocator);
                    break;
                case /* portola.common.api.v1.Connector left_connector */ 2:
                    message.leftConnector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.leftConnector);
                    break;
                case /* portola.common.api.v1.Connector right_connector */ 3:
                    message.rightConnector = Connector.internalBinaryRead(reader, reader.uint32(), options, message.rightConnector);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tunnel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* portola.common.api.v1.TunnelLocator tunnel_locator = 1; */
        if (message.tunnelLocator)
            TunnelLocator.internalBinaryWrite(message.tunnelLocator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Connector left_connector = 2; */
        if (message.leftConnector)
            Connector.internalBinaryWrite(message.leftConnector, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* portola.common.api.v1.Connector right_connector = 3; */
        if (message.rightConnector)
            Connector.internalBinaryWrite(message.rightConnector, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.Tunnel
 */
export const Tunnel = new Tunnel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TunnelList$Type extends MessageType<TunnelList> {
    constructor() {
        super("portola.common.api.v1.TunnelList", [
            { no: 1, name: "tunnel_list", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tunnel }
        ]);
    }
    create(value?: PartialMessage<TunnelList>): TunnelList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tunnelList = [];
        if (value !== undefined)
            reflectionMergePartial<TunnelList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TunnelList): TunnelList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated portola.common.api.v1.Tunnel tunnel_list */ 1:
                    message.tunnelList.push(Tunnel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TunnelList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated portola.common.api.v1.Tunnel tunnel_list = 1; */
        for (let i = 0; i < message.tunnelList.length; i++)
            Tunnel.internalBinaryWrite(message.tunnelList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message portola.common.api.v1.TunnelList
 */
export const TunnelList = new TunnelList$Type();
